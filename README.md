# blind-pairing-core

### Pairing Flow

The pairing flow proceeds as follows:
1. The inviter creates an invitation (a new signing keypair) and shares `{ discoveryKey, secretKey }` with an invitee. `publicKey` is set aside for later use.
2. The invitee discovers peers on `discoveryKey` and sends each peer a payload (the handshake hash signed with `secretKey` along with arbitrary `userData`) encrypted to a key derived from the invite `publicKey`.
3. The inviter verifies the signature against the previously-stored `publicKey`, proving that the invitee has `secretKey`.
4. The inviter sends a response to the invitee containing the `key` (previously withheld).
5. The invitee verifies that `key` corresponds to `discoveryKey`, confirming that the remote peer has read-access to `key` (is a valid inviter).

Note that verifying an invitation cannot be done automatically in `onrequest`. You must provide the correct public key to `req.verify(publicKey)`.

## Usage

```js
import { KeetPairing } from 'blind-pairing-core'

// Inviter generates the invite
const { invite, publicKey } = KeetPairing.createInvite(key) // key is a Hypercore or Autobase key

// pair1 is now listening for all requests on the key's corresponding discoveryKey
pair1.join(key)

const req = pair2.pair(invite, { userData: 'hello world' })
req.on('accepted', () => console.log('accepted!'))

const res = pair1.handleRequest(req)

const userData = res.open(publicKey)
console.log(userData) // hello world

res.confirm()

pair2.handleResponse(res.response)
// req accepted event will fire
```

## API

### KeetPairing API

#### `KeetPairing.createInvite(key)`

Static method to create invites for a given key.

#### `KeetPairing.decodeInvite(encoded)`

Static method to decode invites.

#### `KeetPairing.openRequest(request, publicKey)`

Static method for opening requests.

#### `const pairing = new KeetPairing()`

Instantiate a new pairing manager.

#### `pairing.join(key)`

Accept requests for a given key.

#### `pairing.leave(key)`

Stop accepting requests for a given key.

#### `const req = pairing.pair(invite, { userData })`

Create a new pairing request responding to `invite`.

`req` is an encrypted message that can be distributed to members that can complete the pairing. `userData` will only be available to parties who are autohrised to accept the invite.

#### `const req = pairing.handleRequest(requestInfo)`

Returns a `PairingRequest` object to the caller based of the received `requestInfo`.

#### `pairing.handleResponse(response)`

Receive a response and fulfill any pairing requests if possible.

#### `for (const req of pairing.requests())`

Iterate over all open requests.

### PairingRequest API

#### `req.discoveryKey`
The discovery key of the request.

#### `req.publicKey`
The public key sent by the requester (can be compared with the correct public key).

#### `req.receipt`
A statically verifiable receipt of the pairing request (can be verified by third parties).

#### `req.userData`
Optional user data sent by the requester.

#### `const userData = req.open(publicKey)`
Verify that the request signature matches the known public key and decrypt the payload.

Protopair cannot do this automatically, because pairing servers might receive requests for unknown public keys.

`req.confirm` should only be called if req passes `req.verify(publicKey)`.

#### `req.confirm()`

If `req.publicKey` matches the `publicKey` generated by `createInvite` above, and any additional app logic also passes, then the invitation can be confirmed.

This will send `key` back to the requester.

#### `req.deny()`

Will reject the request without sending a response back to the requester.

### ClientRequest API

#### `req.discoveryKey`
The discovery key of the request.

#### `req.publicKey`
The public key sent by the requester (can be compared with the correct public key).

#### `req.userData`
Optional user data sent by the requester.

#### `req.signature`
Lazily set immediately before the request is sent. Verified by the server before emitting the request as valid.

#### `req.destroy()`

Destroy the request.

#### `req.on('accepted', key => { ... })`

An event that fires when an invite is accepted.

#### `req.on('rejected', err => { ... })`

An event that fires when an invite is rejected.

## License
MIT
